## 实战篇：

### 商家缓存

添加商家redis缓存可以有效降低访问速度，因为访问完成之后数据库会更新一块到redis中，而且redis自带分布式，可以在多个服务器中保存统一的redis数据

redis也会带来一系列问题

首先是如果有大量请求而且并不在缓存中，这样会大量请求直接到达数据库导致数据库的压力很大，为了降低压力我们会使用布隆过滤加缓存空对象的方法避免大量压力直接给到数据库

**缓存穿透：**以上便是缓存穿透的问题，布隆过滤负责请求到达redis和数据库之前就检查一遍是否存在，另外因为布隆过滤是hash结构的，所以如果过滤出来是有的其实也可能没有，但是没有的数据在数据库中是肯定没有的，然后数据经过布隆过滤到达了redis，redis检查没有数据，所以就直接打在数据库里了，接着就是数据库查询也没有，但是这样如果这个数据一直请求也不是办法，所以我们缓存空对象到达redis中，注意空对象是的过期时间比普通对象短很多因为不想让没用的数据占用锅过多内存，这样筛选过的数据请求就对数据库压力非常轻了

**缓存雪崩**：指的是redis缓存中大量缓存同时失效，我们可以在redis缓存的过期时间上加上随机时间，使其不要同时过期，但是这样不是办法，所以我们还可以做多级缓存，利用redis集群提高数据可用

所以我们还可以让缓存的过期时间设置成为逻辑过期，即永不过期，虽然如此但是在redis中还是还会有真正的过期时间，我们请求每次获取内容后都会检查内容中的过期时间是否真的过期了，如果过期就拿到锁开辟新线程，这个新线程负责更新，其他同时来请求的数据也会发现数据过期了，但是获取不了锁，所以就会拿到旧数据返回（异步更新）

**缓存击穿**：热点key，热点key失效了，这时我们也用逻辑过期，过期后返回旧数据新线程更新数据，不过在这里要允许读取旧值的时候才用，普遍的做法是用互斥锁，但是锁的问题是慢无法及时获取数据，看需求使用

### 优惠券秒杀

全局唯一id

规律性不能太明显，所以我们用不规律的id生成，高可用，高性能，唯一性，递增性，安全性，可以用redis的全局id生成器，第一位是符号位，31bit位数的以秒为最小精准度的时间戳，然后是32的序列号

优惠券秒杀下单

超卖问题

一人一单

分布式锁

redis消息队列异步秒杀



