# 苍穹外卖

## **1. 项目结构**

Controller → Service → ServiceImpl → Mapper → Database

经典的三层架构，使得职责分离，代码可维护，可测试

### **1.1 Controller**

- 负责接受前端请求


- 校验参数


-  调用Service层完成业务逻辑


- 返回相应结果给前端

#### 1.1.1 增加（insert）

#### 1.1.2 修改（update）

####1.1.3 查询（select）

分页查询

根据名字模糊查找，状态查找，id查找

####1.1.4 删除（delect）

分为单独的删除以及数据库之间的删除，多点删除，

单独删除

联级删除

### Service

只定义方法，不实现

方便单元测试，AOP（事物，日志等）

业务层接口

定义业务逻辑方法的接口

对controller层提供统一的业务逻辑调用入口

可以被**多个**Controller调用



### ServiceImpl

业务层实现

实现service接口，处理业务逻辑

可以做事物控制

MAPPER

对接数据库，进行数据操作

## 技术栈

###Redis



比数据库更小更快的数据存储，Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：

常用Redis命令：

~~~
- SET key value 					         设置指定key的值
- GET key                                        获取指定key的值
- SETEX key seconds value         设置指定key的值，并将 key 的过期时间设为 seconds 秒
- SETNX key value                        只有在 key    不存在时设置 key 的值
另外Redis也像数据库一样不区分字母大小写，但人们习惯大写命名

~~~

哈希操作命名

~~~
- HSET key field value             将哈希表 key 中的字段 field 的值设为 value
- HGET key field                       获取存储在哈希表中指定字段的值
- HDEL key field                       删除存储在哈希表中的指定字段
- HKEYS key                              获取哈希表中所有字段
- HVALS key                              获取哈希表中所有值
~~~



### AOP

面向切面编程，将方法里的业务逻辑和通用逻辑独立出来，即

### 事物控制

token，session，cookie

### JDBC





HttpClient

java中提供支持HTTP协议的客户端编程工具包![](F:\Desktop\苍穹外卖\img\image-20221203185003231.png)

------

## 1️⃣ JDBC 的基本概念

JDBC 是 **Java 提供的标准数据库访问接口**，它定义了一套 API，用来操作关系型数据库（如 MySQL、Oracle、PostgreSQL 等）。

简单说，JDBC 是 **Java 程序和数据库之间的桥梁**。

------

## 2️⃣ JDBC 的核心组成

JDBC 主要由 **四大核心接口** 组成：

| 接口                              | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `DriverManager`                   | 管理数据库驱动，获取数据库连接。                             |
| `Connection`                      | 数据库连接对象，负责事务、创建语句对象等。                   |
| `Statement` / `PreparedStatement` | 执行 SQL 的对象。`PreparedStatement` 支持参数化 SQL，防止 SQL 注入。 |
| `ResultSet`                       | 查询结果集，封装数据库返回的数据。                           |

------

## 3️⃣ JDBC 使用流程

### 典型步骤

```
// 1. 注册驱动
Class.forName("com.mysql.cj.jdbc.Driver");

// 2. 获取连接
Connection conn = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/sky_take_out?serverTimezone=Asia/Shanghai",
    "root",
    "root"
);

// 3. 创建语句对象
String sql = "SELECT * FROM setmeal WHERE category_id = ?";
PreparedStatement ps = conn.prepareStatement(sql);
ps.setLong(1, 13L);

// 4. 执行 SQL
ResultSet rs = ps.executeQuery();

// 5. 处理结果
while (rs.next()) {
    System.out.println("套餐名称：" + rs.getString("name"));
}

// 6. 关闭资源
rs.close();
ps.close();
conn.close();
```

------

## 4️⃣ 优缺点

### 优点

- 标准 API，跨数据库。
- 支持事务管理。
- 可以直接操作原始 SQL，灵活性高。

### 缺点

- 编写 JDBC 代码比较繁琐。
- 需要手动关闭连接和资源，容易泄漏。
- 数据映射需要手动实现（`ResultSet` → Java 对象）。

------

## 5️⃣ 在 Spring 项目中的替代方案

在你做的 **Spring + MyBatis 项目** 中：

- **MyBatis** 本质上还是用 JDBC 来操作数据库，但它帮你：
  - 自动映射 SQL 结果到实体对象
  - 管理 SQL 会话和事务
  - 支持动态 SQL
- **Spring JDBC Template** 是另一种封装，简化 JDBC 编程。

示例（Spring JdbcTemplate）：

```
@Autowired
private JdbcTemplate jdbcTemplate;

public List<Setmeal> listByCategoryId(Long categoryId){
    String sql = "SELECT * FROM setmeal WHERE category_id = ?";
    return jdbcTemplate.query(sql, new Object[]{categoryId},
        (rs, rowNum) -> {
            Setmeal s = new Setmeal();
            s.setId(rs.getLong("id"));
            s.setName(rs.getString("name"));
            return s;
        });
}
```

------

总结：

- **JDBC 是底层，MyBatis/ORM 是封装**
- Spring 项目中，一般不直接使用 JDBC，而是通过 MyBatis 或 JdbcTemplate 简化操作
- 理解 JDBC 对调试 SQL、理解事务和连接管理很有帮助

------

我可以帮你画一个 **JDBC → MyBatis → Spring Service → Controller** 的调用流程图，让你直观理解数据库操作是怎么一层层封装起来的。

你希望我画吗？

好的，我们来系统地梳理 **Token、Session、Cookie** 以及它们在 Web 开发中的关系和区别。为了方便理解，我会结合你的项目场景（Spring Boot + 前后端分离）来讲。

------

## 1️⃣ Cookie

### 定义

- **Cookie** 是服务器存储在客户端浏览器的一小段文本，用于在客户端和服务器之间传递信息。
- 通常包含 **用户标识、会话信息、过期时间等**。

### 特点

- 由浏览器自动在每次 HTTP 请求时带上（`Cookie` 头）。
- 存储在客户端，大小有限制（一般 4KB）。
- 可以设置过期时间（Session Cookie vs Persistent Cookie）。

### 用法举例

```
Set-Cookie: sessionId=abc123; Path=/; HttpOnly
```

------

## 2️⃣ Session

### 定义

- **Session** 是服务器端保存的用户状态信息。
- 每个用户会话对应一个唯一的 **Session ID**。

### 特点

- 存储在服务器端（内存、数据库、Redis 等）。
- 客户端通常只存 **Session ID**（通过 Cookie 或请求头）。
- 用于保存登录状态、购物车、用户信息等。

### 使用流程

1. 用户第一次访问网站 → 服务器生成 Session 对象 + Session ID。
2. Session ID 返回客户端（通常放在 Cookie）。
3. 后续请求带上 Session ID → 服务器找到对应的 Session 数据。

------

## 3️⃣ Token

### 定义

- **Token** 是一种无状态认证方式（尤其在前后端分离中）。
- 常见的是 **JWT（JSON Web Token）**。

### 特点

- 完全存储在客户端（前端通常存在 LocalStorage / SessionStorage / Cookie）。
- 服务端不保存状态（无状态），每次请求只要携带 Token 就能验证用户身份。
- 可以携带一些用户信息（例如用户 ID、角色等），无需每次查数据库。

### JWT 示例

```
// Payload
{
  "userId": 123,
  "username": "wangyating",
  "exp": 1710000000
}
```

请求头：

```
Authorization: Bearer <token字符串>
```

------

## 4️⃣ 对比总结

| 特性     | Cookie                            | Session            | Token (JWT)                                  |
| -------- | --------------------------------- | ------------------ | -------------------------------------------- |
| 存储位置 | 客户端                            | 服务器             | 客户端                                       |
| 安全性   | 易被篡改（需加 HttpOnly, Secure） | 高                 | 高（签名防篡改）                             |
| 状态     | 客户端存储状态                    | 服务器存储状态     | 无状态（自包含）                             |
| 使用场景 | 保存偏好、Session ID              | 登录状态、购物车   | 前后端分离认证                               |
| 优点     | 浏览器自动携带                    | 安全、可存大量数据 | 无状态、跨域方便、可自包含信息               |
| 缺点     | 容量小，安全需注意                | 占用服务器资源     | 客户端存储安全需注意，Token 失效需要刷新机制 |

------

## 5️⃣ Spring Boot + 前后端分离推荐

- **传统 Web 应用** → Cookie + Session
- **前后端分离 / 移动端** → Token（JWT）
- Redis 可以用作 Session 或 Token 黑名单管理，提高性能和安全性

示例（JWT 在 Spring Boot 中）：

```
// 登录成功后生成 token
String token = Jwts.builder()
    .setSubject(user.getId().toString())
    .setExpiration(new Date(System.currentTimeMillis() + 3600_000))
    .signWith(SignatureAlgorithm.HS256, secretKey)
    .compact();
return token;
```

前端每次请求：

```
GET /api/user/info
Authorization: Bearer <token>
```

------

好的，我们来系统梳理 **拦截器（Interceptor）** 和 **过滤器（Filter）**，并对比它们的作用、执行时机以及适用场景。为了结合你的 Spring Boot 项目，我会附带示例。

------

## 1️⃣ 过滤器（Filter）

### 定义

- **Filter** 是 **Servlet 规范的一部分**，属于 Java EE 层面的组件。
- 可以在请求到达 Servlet 之前或响应返回客户端之前，对请求和响应进行 **预处理或后处理**。

### 特点

- **生命周期**：由容器管理（Tomcat）。
- **应用范围**：整个应用（可配置 URL Pattern）。
- **顺序执行**：可以配置多个过滤器，按顺序执行。
- **作用**：统一处理请求日志、编码、CORS、请求体修改、安全校验等。

### Spring Boot 示例

```
@Component
public class MyFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;
        System.out.println("Filter: 请求URL => " + req.getRequestURI());
        // 放行请求
        chain.doFilter(request, response);
        System.out.println("Filter: 响应已返回");
    }
}
```

------

## 2️⃣ 拦截器（Interceptor）

### 定义

- **Interceptor** 是 Spring MVC 提供的组件。
- 工作在 **Controller 层**，可以在请求到达 Controller 之前或处理完成之后执行。

### 特点

- **生命周期**：由 Spring 容器管理。
- **执行时机**：
  1. `preHandle()`：Controller 方法调用前
  2. `postHandle()`：Controller 方法调用后，渲染视图前
  3. `afterCompletion()`：整个请求完成后（可用于资源清理）
- **作用**：权限校验、日志、性能监控、请求参数检查等。
- **只能拦截 Spring MVC 请求**，不能拦截静态资源或非 MVC 请求。

### Spring Boot 示例

```
@Component
public class MyInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        System.out.println("Interceptor: 请求URL => " + request.getRequestURI());
        return true; // true 放行，false 拦截
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response,
                           Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("Interceptor: Controller 已执行");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                                Object handler, Exception ex) throws Exception {
        System.out.println("Interceptor: 请求处理完成");
    }
}
```

### 注册拦截器

```
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private MyInterceptor myInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(myInterceptor)
                .addPathPatterns("/admin/**") // 拦截路径
                .excludePathPatterns("/admin/login"); // 排除路径
    }
}
```

------

## 3️⃣ 区别对比

| 特性     | Filter                                        | Interceptor                      |
| -------- | --------------------------------------------- | -------------------------------- |
| 所属     | Servlet 规范                                  | Spring MVC                       |
| 作用范围 | 所有请求（Servlet 请求）                      | Controller 方法请求              |
| 执行阶段 | 请求到达 Servlet 前/响应返回前                | Controller 调用前/后             |
| 配置方式 | web.xml / @Component / FilterRegistrationBean | Spring 配置 / WebMvcConfigurer   |
| 典型用途 | 请求日志、编码、CORS、安全防护                | 权限校验、请求参数检查、性能监控 |
| 顺序     | 可配置多个，顺序执行                          | 可配置多个，按注册顺序执行       |

------

💡 **总结**：

- 如果需要在 **整个请求生命周期**（包括静态资源）处理请求 → 用 **Filter**。
- 如果只需要处理 **Controller 请求** → 用 **Interceptor**。
- 在项目中，通常 **权限校验**、**JWT token 验证** 用拦截器；而 **编码统一设置、跨域处理、日志打印** 用过滤器。

------

我可以帮你画一张 **请求从浏览器到后端，Filter 和 Interceptor 执行顺序图**，让你一眼就看懂它们的执行关系。

你希望我画吗？

